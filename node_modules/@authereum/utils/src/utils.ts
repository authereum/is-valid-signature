import BN from 'bn.js'
import * as ethjsutil from 'ethereumjs-util'
import prepareHex from 'normalize-hex'
import * as web3utils from 'web3-utils'
import * as checksumUtils from 'ethereum-checksum-address'
import privKeyToAddress from 'ethereum-private-key-to-address'
import Web3 from 'web3'
import anyToHex from 'to-hex'

export const toChecksumAddress = (address:string) => {
  return checksumUtils.toChecksumAddress(address)
}

export const normalizeHex = (hex:string) => {
  return prepareHex(hex, {evenLength: true, addPrefix: true})
}

export const toBN = (value:any, base?:any) => new BN(value, base)

export const removeHexPrefix = (str:string) => (str || '').replace(/^0x/, '')

export const addHexPrefix = (str:string) => `0x${removeHexPrefix(str)}`

export const generateMethodSignature = (name:string, ...params:any) => {
  return web3utils.sha3(`${name}(${params.join(',')})`).substr(0, 10)
}

export const ecrecover = (messageHash:string, signature:string) => {
  const { v, r, s } = ethjsutil.fromRpcSig(signature)
  const messageBuffer = ethjsutil.toBuffer(messageHash)
  const publicKey = ethjsutil.ecrecover(messageBuffer, v, r, s)
  return publicKeyToAddress(publicKey.toString('hex'))
}

export const publicKeyToAddress = (publicKey:string) => {
  return '0x' + ethjsutil.pubToAddress(Buffer.from(removeHexPrefix(publicKey), 'hex')).toString('hex')
}

export const privateKeyToAddress = (privateKey:string) => {
  return privKeyToAddress(privateKey)
}

export const ensNameHash = (name:string) => {
  let result = web3utils.padLeft('0x0', 64)
  const labels = name.split('.')

  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const labelHash = web3utils.sha3(labels[i])
      .substr(2)
    result = web3utils.sha3(`${result}${labelHash}`)
  }

  return result
}

export const ensLabelHash = (name:string) => {
  const [label] = name.split('.')
  return web3utils.sha3(label)
}

export const soliditySha3 = web3utils.soliditySha3

export const keccack256 = soliditySha3

export const keccack256WithPrefix = (message:string) => {
  let size = Buffer.from(message).byteLength
  if (message.startsWith('0x')) {
    size = Buffer.from(removeHexPrefix(message), 'hex').byteLength
  }

  return keccack256(`\x19Ethereum Signed Message:\n${size}`, message)
}

export const toWei = (amount:any, unit:any = 'ether') => {
  return web3utils.toWei(amount, unit)
}

export const fromWei = (amount:any, unit:any = 'ether') => {
  return web3utils.fromWei(amount, unit)
}

export const toHex = (value:any, opts?:any) => anyToHex(value, opts)

export const valueToString = (value:any) => {
  if (typeof value === 'number') {
    return value.toString()
  } else if (typeof value === 'string') {
    if (!value.startsWith('0x')) {
      value = Number(value)
    }

    const hexValue = toHex(value)
    return toBN(hexValue, 16).toString()
  } else {
    console.error("Value cannot be converted to string")
    return null
  }
}
