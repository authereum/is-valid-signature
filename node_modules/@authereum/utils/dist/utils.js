"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bn_js_1 = __importDefault(require("bn.js"));
const ethjsutil = __importStar(require("ethereumjs-util"));
const normalize_hex_1 = __importDefault(require("normalize-hex"));
const web3utils = __importStar(require("web3-utils"));
const checksumUtils = __importStar(require("ethereum-checksum-address"));
const ethereum_private_key_to_address_1 = __importDefault(require("ethereum-private-key-to-address"));
const to_hex_1 = __importDefault(require("to-hex"));
exports.toChecksumAddress = (address) => {
    return checksumUtils.toChecksumAddress(address);
};
exports.normalizeHex = (hex) => {
    return normalize_hex_1.default(hex, { evenLength: true, addPrefix: true });
};
exports.toBN = (value, base) => new bn_js_1.default(value, base);
exports.removeHexPrefix = (str) => (str || '').replace(/^0x/, '');
exports.addHexPrefix = (str) => `0x${exports.removeHexPrefix(str)}`;
exports.generateMethodSignature = (name, ...params) => {
    return web3utils.sha3(`${name}(${params.join(',')})`).substr(0, 10);
};
exports.ecrecover = (messageHash, signature) => {
    const { v, r, s } = ethjsutil.fromRpcSig(signature);
    const messageBuffer = ethjsutil.toBuffer(messageHash);
    const publicKey = ethjsutil.ecrecover(messageBuffer, v, r, s);
    return exports.publicKeyToAddress(publicKey.toString('hex'));
};
exports.publicKeyToAddress = (publicKey) => {
    return '0x' + ethjsutil.pubToAddress(Buffer.from(exports.removeHexPrefix(publicKey), 'hex')).toString('hex');
};
exports.privateKeyToAddress = (privateKey) => {
    return ethereum_private_key_to_address_1.default(privateKey);
};
exports.ensNameHash = (name) => {
    let result = web3utils.padLeft('0x0', 64);
    const labels = name.split('.');
    for (let i = labels.length - 1; i >= 0; i -= 1) {
        const labelHash = web3utils.sha3(labels[i])
            .substr(2);
        result = web3utils.sha3(`${result}${labelHash}`);
    }
    return result;
};
exports.ensLabelHash = (name) => {
    const [label] = name.split('.');
    return web3utils.sha3(label);
};
exports.soliditySha3 = web3utils.soliditySha3;
exports.keccack256 = exports.soliditySha3;
exports.keccack256WithPrefix = (message) => {
    let size = Buffer.from(message).byteLength;
    if (message.startsWith('0x')) {
        size = Buffer.from(exports.removeHexPrefix(message), 'hex').byteLength;
    }
    return exports.keccack256(`\x19Ethereum Signed Message:\n${size}`, message);
};
exports.toWei = (amount, unit = 'ether') => {
    return web3utils.toWei(amount, unit);
};
exports.fromWei = (amount, unit = 'ether') => {
    return web3utils.fromWei(amount, unit);
};
exports.toHex = (value, opts) => to_hex_1.default(value, opts);
exports.valueToString = (value) => {
    if (typeof value === 'number') {
        return value.toString();
    }
    else if (typeof value === 'string') {
        if (!value.startsWith('0x')) {
            value = Number(value);
        }
        const hexValue = exports.toHex(value);
        return exports.toBN(hexValue, 16).toString();
    }
    else {
        console.error("Value cannot be converted to string");
        return null;
    }
};
//# sourceMappingURL=utils.js.map